# -*- coding: utf-8 -*-
"""fit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eckglYbUg9PiSIPIe0z58pH_ybGxGYtO
"""
import sys
import os
sys.path.append(os.path.abspath("."))

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
from models.ode_models import (
    simulate_one_comp_iv_bolus,
    simulate_one_comp_po,
    simulate_two_comp_iv_bolus,
    simulate_two_comp_po,
    simulate_one_comp_iv_infusion
)
from models.iv_infusion import one_comp_iv_infusion_conc

def fit_model(data, model_name, method, dose=None, R=None, duration=None):
    time = data['time'].values
    conc = data['conc'].values

    if model_name == "1 컴파트먼트 IV bolus":
        if method == "지수함수 기반":
            def model_func(t, k10, V):
                return (dose / V) * np.exp(-k10 * t)
        else:
            def model_func(t, k10, V):
                return simulate_one_comp_iv_bolus(t, dose, k10, V)

        popt, _ = curve_fit(model_func, time, conc, bounds=(0, np.inf))
        pred = model_func(time, *popt)
        params = dict(zip(["k10", "V"], popt))

    elif model_name == "1 컴파트먼트 PO":
        if method == "지수함수 기반":
            def model_func(t, ka, k, V):
                return (dose * ka) / (V * (ka - k)) * (np.exp(-k * t) - np.exp(-ka * t))
        else:
            def model_func(t, ka, k, V):
                return simulate_one_comp_po(t, dose, ka, k, V)

        popt, _ = curve_fit(model_func, time, conc, bounds=(0, np.inf), maxfev=10000)
        pred = model_func(time, *popt)
        params = dict(zip(["ka", "k", "V"], popt))

    elif model_name == "2 컴파트먼트 IV bolus":
        if method == "지수함수 기반":
            def model_func(t, A, alpha, B, beta):
                return A * np.exp(-alpha * t) + B * np.exp(-beta * t)

            popt, _ = curve_fit(model_func, time, conc, bounds=(0, np.inf))
            pred = model_func(time, *popt)
            params = dict(zip(["A", "alpha", "B", "beta"], popt))
        else:
            def model_func(t, k10, k12, k21, V1):
                return simulate_two_comp_iv_bolus(t, dose, k10, k12, k21, V1)

            popt, _ = curve_fit(model_func, time, conc, bounds=(0, np.inf), maxfev=20000)
            pred = model_func(time, *popt)
            params = dict(zip(["k10", "k12", "k21", "V1"], popt))

    elif model_name == "2 컴파트먼트 PO":
        def model_func(t, ka, k10, k12, k21, V1):
            return simulate_two_comp_po(t, dose, ka, k10, k12, k21, V1)

        popt, _ = curve_fit(model_func, time, conc, bounds=(0, np.inf), maxfev=20000)
        pred = model_func(time, *popt)
        params = dict(zip(["ka", "k10", "k12", "k21", "V1"], popt))

    elif model_name == "IV infusion (PI)":
        if method == "지수함수 기반":
            def model_func(t, k10, V):
                return one_comp_iv_infusion_conc(t, R, k10, V, duration)
        else:
            def model_func(t, k10, V):
                return simulate_one_comp_iv_infusion(t, R, k10, V, duration)

        popt, _ = curve_fit(model_func, time, conc, bounds=(0, np.inf), maxfev=10000)
        pred = model_func(time, *popt)
        params = dict(zip(["k10", "V"], popt))

    else:
        raise ValueError("지원되지 않는 모델입니다.")

    residuals = conc - pred
    ss_res = np.sum(residuals ** 2)
    n = len(conc)
    k = len(popt)
    aic = n * np.log(ss_res / n) + 2 * k
    bic = n * np.log(ss_res / n) + k * np.log(n)

    return {
        "params": {key: round(val, 4) for key, val in params.items()},
        "pred": pred,
        "aic": aic,
        "bic": bic
    }
