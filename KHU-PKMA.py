# -*- coding: utf-8 -*-
"""KHU-PKMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16sn_xGc60H2sP6PJZubL0eXRRLhtQQBM
"""

# 📦 약물동태학 통합 분석 앱 (분석 방법 분리: NCA / Compartmental)
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.integrate import odeint
from scipy import stats

st.set_page_config(layout="wide")
st.title("💊 약물동태학 통합 분석 앱")

#-----------------------------#
# 📁 데이터 입력
#-----------------------------#
st.sidebar.header("📂 데이터 입력")
example = st.sidebar.checkbox("예제 데이터 사용", value=True)

if example:
    time = np.array([0.5, 1, 2, 4, 6, 8, 12])
    conc = np.array([15.3, 13.1, 10.0, 6.1, 4.2, 2.9, 1.3])
    df = pd.DataFrame({'time': time, 'conc': conc})
else:
    uploaded_file = st.sidebar.file_uploader("CSV 업로드 (time, conc 열 포함)", type="csv")
    if uploaded_file:
        df = pd.read_csv(uploaded_file)
    else:
        st.warning("CSV 파일을 업로드하거나 예제 데이터를 선택하세요.")
        st.stop()

#-----------------------------#
# 🧭 분석 방법 선택
#-----------------------------#
analysis_type = st.sidebar.radio("🔍 분석 방법 선택", ["NCA 분석", "컴파트먼트 모델 분석"])

#-----------------------------#
# ⚙️ 공통 모델 정의
#-----------------------------#
def exp_model_iv(t, k10, V, dose):
    return dose / V * np.exp(-k10 * t)

def exp_model_po(t, ka, k, V, dose):
    return (dose * ka) / (V * (ka - k)) * (np.exp(-k * t) - np.exp(-ka * t))

def two_comp_model(t, A, alpha, B, beta):
    return A * np.exp(-alpha * t) + B * np.exp(-beta * t)

def two_comp_po_model(t, ka, A, alpha, B, beta):
    return ka * (A / (ka - alpha) * (np.exp(-alpha * t) - np.exp(-ka * t)) +
                 B / (ka - beta) * (np.exp(-beta * t) - np.exp(-ka * t)))

def simulate_ode_iv(t, dose, k10, V):
    def ode_iv(y, t): return [-k10 * y[0]]
    y0 = [dose]
    result = odeint(ode_iv, y0, t)
    return result[:, 0] / V

def simulate_ode_po(t, dose, ka, k, V):
    def ode_po(y, t):
        A_gut, A_central = y
        return [-ka * A_gut, ka * A_gut - k * A_central]
    y0 = [dose, 0]
    result = odeint(ode_po, y0, t)
    return result[:, 1] / V

def simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1):
    def model(y, t):
        A1, A2 = y
        dA1dt = -k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA1dt, dA2dt]
    y0 = [dose, 0]
    result = odeint(model, y0, t)
    return result[:, 0] / V1

def simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1):
    def model(y, t):
        A_gut, A1, A2 = y
        dA_gut_dt = -ka * A_gut
        dA1dt = ka * A_gut - k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA_gut_dt, dA1dt, dA2dt]
    y0 = [dose, 0, 0]
    result = odeint(model, y0, t)
    return result[:, 1] / V1

def perform_nca(df, terminal_indices=None):
    t, c = df['time'].values, df['conc'].values
    auc = np.trapz(c, t)
    if terminal_indices is not None:
        slope, _, _, _, _ = stats.linregress(t[terminal_indices], np.log(c[terminal_indices]))
    else:
        slope, _, _, _, _ = stats.linregress(t[-3:], np.log(c[-3:]))
    kel = -slope
    half_life = np.log(2) / kel
    clearance = st.sidebar.number_input("투여량 (mg)", value=100.0) / auc
    return auc, kel, half_life, clearance



#-----------------------------#
# 🧮 컴파트먼트 모델 분석
#-----------------------------#
elif analysis_type == "컴파트먼트 모델 분석":
    model = st.sidebar.selectbox("모델 선택", [
        "1C IV (Exp)", "1C IV (ODE)",
        "1C PO (Exp)", "1C PO (ODE)",
        "2C IV (Exp)", "2C PO (Exp)",
        "2C IV (ODE)", "2C PO (ODE)"
    ])
    dose = st.sidebar.number_input("투여량 (mg)", value=100.0)
    log_y = st.sidebar.checkbox("로그 스케일", value=False)

    def fit_model(df, model):
        t = df['time'].values
        y = df['conc'].values

        if model == "1C IV (Exp)":
            popt, _ = curve_fit(lambda t, k10, V: exp_model_iv(t, k10, V, dose), t, y, bounds=(0, np.inf))
            pred = exp_model_iv(t, *popt, dose)
            params = dict(zip(["k10", "V"], popt))

        elif model == "1C PO (Exp)":
            popt, _ = curve_fit(lambda t, ka, k, V: exp_model_po(t, ka, k, V, dose), t, y, bounds=(0, np.inf))
            pred = exp_model_po(t, *popt, dose)
            params = dict(zip(["ka", "k", "V"], popt))

        elif model == "2C IV (Exp)":
            popt, _ = curve_fit(two_comp_model, t, y, bounds=(0, np.inf))
            pred = two_comp_model(t, *popt)
            params = dict(zip(["A", "alpha", "B", "beta"], popt))

        elif model == "2C PO (Exp)":
            popt, _ = curve_fit(lambda t, ka, A, alpha, B, beta: two_comp_po_model(t, ka, A, alpha, B, beta),
                                t, y, bounds=(0, np.inf))
            pred = two_comp_po_model(t, *popt)
            params = dict(zip(["ka", "A", "alpha", "B", "beta"], popt))

        elif model == "1C IV (ODE)":
            def model_func(t, k10, V): return simulate_ode_iv(t, dose, k10, V)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["k10", "V"], popt))

        elif model == "1C PO (ODE)":
            def model_func(t, ka, k, V): return simulate_ode_po(t, dose, ka, k, V)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["ka", "k", "V"], popt))

        elif model == "2C IV (ODE)":
            def model_func(t, k10, k12, k21, V1): return simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["k10", "k12", "k21", "V1"], popt))

        elif model == "2C PO (ODE)":
            def model_func(t, ka, k10, k12, k21, V1): return simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["ka", "k10", "k12", "k21", "V1"], popt))

        residuals = y - pred
        ss_res = np.sum(residuals**2)
        aic = len(y) * np.log(ss_res / len(y)) + 2 * len(popt)
        bic = len(y) * np.log(ss_res / len(y)) + len(popt) * np.log(len(y))
        return pred, params, residuals, aic, bic

    # 실행
    pred, params, residuals, aic, bic = fit_model(df, model)
    df_out = df.copy()
    df_out['Predicted'] = pred
    df_out['Residuals'] = residuals

    col1, col2 = st.columns(2)
    with col1:
        st.subheader("📊 실측 vs 예측")
        fig, ax = plt.subplots()
        ax.plot(df['time'], df['conc'], 'o', label='Observed')
        ax.plot(df['time'], pred, '-', label='Predicted')
        ax.set_xlabel("Time")
        ax.set_ylabel("Concentration")
        if log_y:
            ax.set_yscale("log")
        ax.legend()
        st.pyplot(fig)

    with col2:
        st.subheader("🧮 파라미터 추정 결과")
        for k, v in params.items():
            st.write(f"**{k}**: {v:.4f}")
        st.write(f"**AIC**: {aic:.2f}")
        st.write(f"**BIC**: {bic:.2f}")

    st.subheader("📉 잔차 분석")
    fig2, ax2 = plt.subplots(1, 2, figsize=(10, 4))
    sns.histplot(residuals, kde=True, ax=ax2[0])
    ax2[0].set_title("Residual Histogram")
    ax2[1].scatter(pred, residuals)
    ax2[1].axhline(0, color='gray', linestyle='--')
    ax2[1].set_title("Residuals vs Fitted")
    st.pyplot(fig2)

    st.subheader("📥 결과 다운로드")
    csv = df_out.to_csv(index=False)
    st.download_button("📄 결과 CSV 다운로드", csv, "pk_result.csv", "text/csv")