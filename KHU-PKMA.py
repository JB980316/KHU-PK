# -*- coding: utf-8 -*-
"""KHU-PKMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16sn_xGc60H2sP6PJZubL0eXRRLhtQQBM
"""

# ğŸ“¦ ì•½ë¬¼ë™íƒœí•™ í†µí•© ë¶„ì„ ì•±
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.integrate import odeint
from scipy import stats

st.set_page_config(layout="wide")
st.title("ğŸ’Š KHU-PKMA")
st.caption("Pharmacokinetic Modeling Assistant")

#-----------------------------#
# ğŸ“ ë°ì´í„° ì…ë ¥
#-----------------------------#
st.sidebar.header("ğŸ“‚ ë°ì´í„° ì…ë ¥")
example = st.sidebar.checkbox("ì˜ˆì œ ë°ì´í„° ì‚¬ìš©", value=True)

if example:
    time = np.array([0.5, 1, 2, 4, 6, 8, 12])
    conc = np.array([15.3, 13.1, 10.0, 6.1, 4.2, 2.9, 1.3])
    df = pd.DataFrame({'time': time, 'conc': conc})
else:
    uploaded_file = st.sidebar.file_uploader("CSV ì—…ë¡œë“œ (time, conc ì—´ í¬í•¨)", type="csv")
    
    with st.sidebar.expander("ğŸ“ CSV í˜•ì‹ ì˜ˆì‹œ ë³´ê¸°"):
        st.markdown("""
        ì—…ë¡œë“œí•  CSV íŒŒì¼ì€ ë‹¤ìŒ í˜•ì‹ì„ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤:

        | time | conc |
        |------|------|
        | 0.5  | 15.3 |
        | 1.0  | 13.1 |
        | 2.0  | 10.0 |
        | ...  | ...  |

        - `time`: ì‹œê°„ (ë‹¨ìœ„: ì‹œê°„, h)
        - `conc`: ì•½ë¬¼ ë†ë„ (ì˜ˆ: mg/L)
        - ì—´ ì´ë¦„ì€ ë°˜ë“œì‹œ `time`, `conc`ì—¬ì•¼ í•¨
        - CSV íŒŒì¼ì€ ì‰¼í‘œë¡œ êµ¬ë¶„ë˜ì–´ì•¼ í•¨
        """)
    
    if uploaded_file:
        df = pd.read_csv(uploaded_file)
    else:
        st.warning("CSV íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì˜ˆì œ ë°ì´í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.")
        st.stop()

#-----------------------------#
# ğŸ§­ ë¶„ì„ ë°©ë²• ì„ íƒ
#-----------------------------#
analysis_type = st.sidebar.radio("ğŸ” ë¶„ì„ ë°©ë²• ì„ íƒ", ["NCA ë¶„ì„", "ì»´íŒŒíŠ¸ë¨¼íŠ¸ ëª¨ë¸ ë¶„ì„"])

#-----------------------------#
# âš™ï¸ ê³µí†µ ëª¨ë¸ í•¨ìˆ˜ ì •ì˜
#-----------------------------#
def exp_model_iv(t, k10, V, dose): return dose / V * np.exp(-k10 * t)

def exp_model_po(t, ka, k, V, dose):
    return (dose * ka) / (V * (ka - k)) * (np.exp(-k * t) - np.exp(-ka * t))

def two_comp_model(t, A, alpha, B, beta):
    return A * np.exp(-alpha * t) + B * np.exp(-beta * t)

def two_comp_po_model(t, ka, A, alpha, B, beta):
    return ka * (A / (ka - alpha) * (np.exp(-alpha * t) - np.exp(-ka * t)) +
                 B / (ka - beta) * (np.exp(-beta * t) - np.exp(-ka * t)))

def simulate_ode_iv(t, dose, k10, V):
    def ode_iv(y, t): return [-k10 * y[0]]
    y0 = [dose]
    result = odeint(ode_iv, y0, t)
    return result[:, 0] / V

def simulate_ode_po(t, dose, ka, k, V):
    def ode_po(y, t):
        A_gut, A_central = y
        return [-ka * A_gut, ka * A_gut - k * A_central]
    y0 = [dose, 0]
    result = odeint(ode_po, y0, t)
    return result[:, 1] / V

def simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1):
    def model(y, t):
        A1, A2 = y
        dA1dt = -k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA1dt, dA2dt]
    y0 = [dose, 0]
    result = odeint(model, y0, t)
    return result[:, 0] / V1

def simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1):
    def model(y, t):
        A_gut, A1, A2 = y
        dA_gut_dt = -ka * A_gut
        dA1dt = ka * A_gut - k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA_gut_dt, dA1dt, dA2dt]
    y0 = [dose, 0, 0]
    result = odeint(model, y0, t)
    return result[:, 1] / V1

def perform_nca(df, terminal_indices=None):
    t, c = df['time'].values, df['conc'].values
    auc = np.trapz(c, t)
    if terminal_indices:
        slope, _, _, _, _ = stats.linregress(t[terminal_indices], np.log(c[terminal_indices]))
    else:
        slope, _, _, _, _ = stats.linregress(t[-3:], np.log(c[-3:]))
    kel = -slope
    t12 = np.log(2) / kel
    dose = st.sidebar.number_input("íˆ¬ì—¬ëŸ‰ (mg)", value=100.0)
    cl = dose / auc
    return auc, kel, t12, cl

#-----------------------------#
# ğŸ“ NCA ë¶„ì„
#-----------------------------#
if analysis_type == "NCA ë¶„ì„":
    st.subheader("ğŸ“ NCA ë¶„ì„")

    auto_mode = st.radio("í„°ë¯¸ë„ í˜ì´ì¦ˆ ì„ íƒ", ["ìë™", "ìˆ˜ë™"])
    if auto_mode == "ìˆ˜ë™":
        selected_points = st.multiselect("í„°ë¯¸ë„ êµ¬ê°„ ì‹œê°„ ì„ íƒ", df['time'].tolist(), default=df['time'].tolist()[-3:])
        terminal_idx = df.index[df['time'].isin(selected_points)].tolist()
    else:
        terminal_idx = None

    auc, kel, t12, cl = perform_nca(df, terminal_idx)

    st.markdown(f"""
    **AUClast:** {auc:.2f} (hÂ·mg/L)  
    **Î»z (kel):** {kel:.4f} hâ»Â¹  
    **t1/2:** {t12:.2f} h  
    **CL:** {cl:.2f} L/h
    """)

    st.subheader("ğŸ“ˆ ë†ë„-ì‹œê°„ ê³¡ì„ ")
    fig, ax = plt.subplots()
    ax.plot(df['time'], df['conc'], 'o-', label='Observed')
    ax.set_xlabel("Time")
    ax.set_ylabel("Concentration")
    ax.legend()
    st.pyplot(fig)

#-----------------------------#
# ğŸ§® ì»´íŒŒíŠ¸ë¨¼íŠ¸ ëª¨ë¸ ë¶„ì„
#-----------------------------#
elif analysis_type == "ì»´íŒŒíŠ¸ë¨¼íŠ¸ ëª¨ë¸ ë¶„ì„":
    st.subheader("ğŸ§® ì»´íŒŒíŠ¸ë¨¼íŠ¸ ëª¨ë¸ ë¶„ì„")

    model = st.sidebar.selectbox("ëª¨ë¸ ì„ íƒ", [
        "1C IV (Exp)", "1C PO (Exp)",
        "2C IV (Exp)", "2C PO (Exp)",
        "1C IV (ODE)", "1C PO (ODE)",
        "2C IV (ODE)", "2C PO (ODE)"
    ])
    dose = st.sidebar.number_input("íˆ¬ì—¬ëŸ‰ (mg)", value=100.0)
    use_log = st.sidebar.checkbox("ë¡œê·¸ ìŠ¤ì¼€ì¼ë¡œ ì‹œê°í™”", value=False)

    t = df['time'].values
    y = df['conc'].values

    try:
        # ëª¨ë¸ë³„ í”¼íŒ…
        if model == "1C IV (Exp)":
            popt, _ = curve_fit(lambda t, k10, V: exp_model_iv(t, k10, V, dose), t, y, bounds=(0, np.inf))
            pred = exp_model_iv(t, *popt, dose)
            params = dict(zip(["k10", "V"], popt))

        elif model == "1C PO (Exp)":
            popt, _ = curve_fit(lambda t, ka, k, V: exp_model_po(t, ka, k, V, dose), t, y, bounds=(0, np.inf))
            pred = exp_model_po(t, *popt, dose)
            params = dict(zip(["ka", "k", "V"], popt))

        elif model == "2C IV (Exp)":
            popt, _ = curve_fit(two_comp_model, t, y, bounds=(0, np.inf))
            pred = two_comp_model(t, *popt)
            params = dict(zip(["A", "alpha", "B", "beta"], popt))

        elif model == "2C PO (Exp)":
            popt, _ = curve_fit(lambda t, ka, A, alpha, B, beta: two_comp_po_model(t, ka, A, alpha, B, beta), t, y, bounds=(0, np.inf))
            pred = two_comp_po_model(t, *popt)
            params = dict(zip(["ka", "A", "alpha", "B", "beta"], popt))

        elif model == "1C IV (ODE)":
            def model_func(t, k10, V): return simulate_ode_iv(t, dose, k10, V)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["k10", "V"], popt))

        elif model == "1C PO (ODE)":
            def model_func(t, ka, k, V): return simulate_ode_po(t, dose, ka, k, V)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["ka", "k", "V"], popt))

        elif model == "2C IV (ODE)":
            def model_func(t, k10, k12, k21, V1): return simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["k10", "k12", "k21", "V1"], popt))

        elif model == "2C PO (ODE)":
            def model_func(t, ka, k10, k12, k21, V1): return simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1)
            popt, _ = curve_fit(model_func, t, y, bounds=(0, np.inf))
            pred = model_func(t, *popt)
            params = dict(zip(["ka", "k10", "k12", "k21", "V1"], popt))

        # ë¶„ì„ ê²°ê³¼
        residuals = y - pred
        ss_res = np.sum(residuals**2)
        aic = len(y) * np.log(ss_res / len(y)) + 2 * len(popt)
        bic = len(y) * np.log(ss_res / len(y)) + len(popt) * np.log(len(y))

        col1, col2 = st.columns(2)
        with col1:
            st.subheader("ğŸ“Š ì‹¤ì¸¡ vs ì˜ˆì¸¡")
            fig, ax = plt.subplots()
            ax.plot(t, y, 'o', label='Observed')
            ax.plot(t, pred, '-', label='Predicted')
            ax.set_xlabel("Time")
            ax.set_ylabel("Concentration")
            if use_log:
                ax.set_yscale("log")
            ax.legend()
            st.pyplot(fig)

        with col2:
            st.subheader("ğŸ§® ì¶”ì • íŒŒë¼ë¯¸í„°")
            for k, v in params.items():
                st.write(f"**{k}**: {v:.4f}")
            st.write(f"**AIC**: {aic:.2f}")
            st.write(f"**BIC**: {bic:.2f}")

        st.subheader("ğŸ“‰ ì”ì°¨ ë¶„ì„")
        fig2, ax2 = plt.subplots(1, 2, figsize=(10, 4))
        sns.histplot(residuals, kde=True, ax=ax2[0])
        ax2[0].set_title("Residual Histogram")
        ax2[1].scatter(pred, residuals)
        ax2[1].axhline(0, color='gray', linestyle='--')
        ax2[1].set_title("Residuals vs Fitted")
        st.pyplot(fig2)

        st.subheader("ğŸ“¥ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ")
        df_out = df.copy()
        df_out['Predicted'] = pred
        df_out['Residuals'] = residuals
        csv = df_out.to_csv(index=False)
        st.download_button("ğŸ“„ ê²°ê³¼ CSV ë‹¤ìš´ë¡œë“œ", csv, "pk_result.csv", "text/csv")

    except Exception as e:
        st.error(f"âŒ ëª¨ë¸ í”¼íŒ… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
