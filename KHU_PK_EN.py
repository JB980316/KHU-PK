# -*- coding: utf-8 -*-
"""khu_pk_en.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/139eYdkEvy89_MCzSWPBANReVxl3NebM_
"""

# -*- coding: utf-8 -*-
"""
KHU-PKMA Streamlit App
- NCA: ì›ë˜ ë°©ì‹ ìœ ì§€
- Compartment Model: ì „ë¶€ ODE ê¸°ë°˜ + PKSolver ìŠ¤íƒ€ì¼ ì´ˆê¸°ê°’/Weight
- ODEëŠ” í•­ìƒ t=0ì—ì„œ Dose íˆ¬ì—¬ í›„ ì ë¶„ â†’ ì§€ìˆ˜í•¨ìˆ˜ ë²„ì „ê³¼ ë™ì¼í•œ ëª¨ë¸
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.integrate import odeint
from scipy import stats
import warnings

# ----------------------------- #
# Streamlit page config
# ----------------------------- #
st.set_page_config(layout="wide")
st.title("ğŸ’Š KHU-PKMA")
st.caption("Pharmacokinetic Model Assistant")

# ----------------------------- #
# ğŸ“ Data Input
# ----------------------------- #
st.sidebar.header("ğŸ“‚ Data Input")
example = st.sidebar.checkbox("Use Example Data", value=True)

if example:
    time = np.array([0.5, 1, 2, 4, 6, 8, 12], dtype=float)
    conc = np.array([15.3, 13.1, 10.0, 6.1, 4.2, 2.9, 1.3], dtype=float)
    df = pd.DataFrame({'time': time, 'conc': conc})
else:
    uploaded_file = st.sidebar.file_uploader(
        "Upload CSV (must include 'time','conc' columns)", type="csv"
    )

    with st.sidebar.expander("ğŸ“ View CSV Format Example"):
        st.markdown("""
        The uploaded CSV file must follow this format:

        | time | conc |
        |------|------|
        | 0.5  | 15.3 |
        | 1.0  | 13.1 |
        | 2.0  | 10.0 |
        | ...  | ...  |

        - `time`: Time (hours, h)
        - `conc`: Drug concentration (e.g., mg/L)
        - Column names must be exactly `time`, `conc`
        - CSV must be comma-delimited
        """)

    if uploaded_file:
        df = pd.read_csv(uploaded_file)
        if not set(["time", "conc"]).issubset(df.columns):
            st.error("CSV must have columns named exactly 'time' and 'conc'.")
            st.stop()
        df = df.dropna(subset=["time", "conc"]).copy()
        df["time"] = pd.to_numeric(df["time"], errors="coerce")
        df["conc"] = pd.to_numeric(df["conc"], errors="coerce")
        df = df.dropna(subset=["time", "conc"]).sort_values("time")
        if len(df) < 3:
            st.error("Need at least 3 rows of (time, conc) data.")
            st.stop()
    else:
        st.warning("Please upload a CSV file or select example data.")
        st.stop()

# ê³µí†µ Dose ì…ë ¥
dose = st.sidebar.number_input("Dose (mg)", value=100.0, min_value=0.0, step=10.0)

# ----------------------------- #
# ğŸ§­ Select Analysis Type
# ----------------------------- #
analysis_type = st.sidebar.radio(
    "ğŸ” Select Analysis Type", ["NCA Analysis", "Compartment Model Analysis"]
)

# ----------------------------- #
# âš™ï¸ ODE Model Functions (í•­ìƒ t=0ì—ì„œ íˆ¬ì—¬ í›„ ì ë¶„)
# ----------------------------- #

def simulate_ode_iv(t, dose, k10, V):
    """
    1C IV: dA/dt = -k10*A, C = A/V
    í•­ìƒ t=0ì—ì„œ A(0)=Dose í›„, ê´€ì¸¡ì‹œê°„ tì—ì„œ ë†ë„ë¥¼ ì½ì–´ì˜´
    """
    t = np.asarray(t, dtype=float)
    unique_t, inverse_idx = np.unique(t, return_inverse=True)

    # ë‚´ë¶€ ì‹œê°„ì¶•: í•­ìƒ t=0 í¬í•¨
    if unique_t[0] > 0:
        t_full = np.concatenate(([0.0], unique_t))
        offset = 1  # unique_tëŠ” t_full[1:]ì— í•´ë‹¹
    else:
        t_full = unique_t
        offset = 0

    def ode_iv(A, tt):
        return -k10 * A

    A_full = odeint(ode_iv, dose, t_full).flatten()

    if offset == 1:
        A_unique = A_full[1:]
    else:
        A_unique = A_full

    conc_unique = A_unique / V
    conc = conc_unique[inverse_idx]
    return conc

def simulate_ode_po(t, dose, ka, k, V):
    """
    1C PO: A_gut, A_central
    t=0ì—ì„œ A_gut(0)=Dose, A_c(0)=0 í›„ ì ë¶„
    """
    t = np.asarray(t, dtype=float)
    unique_t, inverse_idx = np.unique(t, return_inverse=True)

    if unique_t[0] > 0:
        t_full = np.concatenate(([0.0], unique_t))
        offset = 1
    else:
        t_full = unique_t
        offset = 0

    def ode_po(y, tt):
        A_gut, A_c = y
        dA_gut = -ka * A_gut
        dA_c = ka * A_gut - k * A_c
        return [dA_gut, dA_c]

    y0 = [dose, 0.0]
    result = odeint(ode_po, y0, t_full)

    if offset == 1:
        A_c_unique = result[1:, 1]
    else:
        A_c_unique = result[:, 1]

    conc_unique = A_c_unique / V
    conc = conc_unique[inverse_idx]
    return conc

def simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1):
    """
    2C IV: A1, A2
    t=0ì—ì„œ A1(0)=Dose, A2(0)=0 í›„ ì ë¶„
    """
    t = np.asarray(t, dtype=float)
    unique_t, inverse_idx = np.unique(t, return_inverse=True)

    if unique_t[0] > 0:
        t_full = np.concatenate(([0.0], unique_t))
        offset = 1
    else:
        t_full = unique_t
        offset = 0

    def model(y, tt):
        A1, A2 = y
        dA1dt = -k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA1dt, dA2dt]

    y0 = [dose, 0.0]
    result = odeint(model, y0, t_full)

    if offset == 1:
        A1_unique = result[1:, 0]
    else:
        A1_unique = result[:, 0]

    conc_unique = A1_unique / V1
    conc = conc_unique[inverse_idx]
    return conc

def simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1):
    """
    2C PO: A_gut, A1, A2
    t=0ì—ì„œ A_gut(0)=Dose, A1(0)=0, A2(0)=0 í›„ ì ë¶„
    """
    t = np.asarray(t, dtype=float)
    unique_t, inverse_idx = np.unique(t, return_inverse=True)

    if unique_t[0] > 0:
        t_full = np.concatenate(([0.0], unique_t))
        offset = 1
    else:
        t_full = unique_t
        offset = 0

    def model(y, tt):
        A_gut, A1, A2 = y
        dA_gut = -ka * A_gut
        dA1dt = ka * A_gut - k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA_gut, dA1dt, dA2dt]

    y0 = [dose, 0.0, 0.0]
    result = odeint(model, y0, t_full)

    if offset == 1:
        A1_unique = result[1:, 1]
    else:
        A1_unique = result[:, 1]

    conc_unique = A1_unique / V1
    conc = conc_unique[inverse_idx]
    return conc

# ----------------------------- #
# NCA (ì›ë˜ ë¡œì§, doseë§Œ ì¸ìë¡œ ë°›ë„ë¡)
# ----------------------------- #
def perform_nca(df, terminal_indices, dose):
    t = df['time'].values.astype(float)
    c = df['conc'].values.astype(float)

    # AUClast
    auc = np.trapz(c, t)

    # terminal êµ¬ê°„ ì„ íƒ
    if terminal_indices is not None and len(terminal_indices) >= 2:
        t_term = t[terminal_indices]
        c_term = c[terminal_indices]
    else:
        mask_pos = c > 0
        t_pos = t[mask_pos]
        c_pos = c[mask_pos]
        if len(t_pos) < 3:
            t_term, c_term = t_pos[-2:], c_pos[-2:]
        else:
            t_term, c_term = t_pos[-3:], c_pos[-3:]

    if len(t_term) < 2 or np.any(c_term <= 0):
        kel = np.nan
        t12 = np.nan
    else:
        slope, _, _, _, _ = stats.linregress(t_term, np.log(c_term))
        kel = -slope
        t12 = np.log(2) / kel if kel > 0 else np.nan

    cl = dose / auc if auc > 0 else np.nan
    return auc, kel, t12, cl

def show_model_info(model):
    st.markdown("### ğŸ“˜ Model Description")

    def safe_image(path, caption):
        try:
            st.image(path, caption=caption, use_container_width=True)
        except Exception:
            pass  # ì´ë¯¸ì§€ íŒŒì¼ ì—†ìœ¼ë©´ ë¬´ì‹œ

    if model == "1 Compartment IV":
        safe_image("images/1CIV.png", "1-Compartment IV Model")
        st.latex(r"\frac{dA}{dt} = -k \cdot A,\quad C(t) = \frac{A(t)}{V}")
        st.markdown("""
        - **k (Elimination rate constant, hâ»Â¹)**
        - **V (Volume of distribution, L)**
        """)

    elif model == "1 Compartment PO":
        safe_image("images/1CPO.png", "1-Compartment PO Model")
        st.latex(r"""
        \begin{cases}
        \frac{dA_g}{dt} = -k_a A_g \\
        \frac{dA_c}{dt} = k_a A_g - k A_c
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_c(t)}{V}")
        st.markdown("""
        - **kâ‚ (Absorption rate constant, hâ»Â¹)**
        - **k (Elimination rate constant, hâ»Â¹)**
        - **V (L)**
        """)

    elif model == "2 Compartment IV":
        safe_image("images/2CIV.png", "2-Compartment IV Model")
        st.latex(r"""
        \begin{cases}
        \frac{dA_1}{dt} = -k_{10}A_1 - k_{12}A_1 + k_{21}A_2 \\
        \frac{dA_2}{dt} = k_{12}A_1 - k_{21}A_2
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_1(t)}{V_1}")
        st.markdown("""
        - **kâ‚â‚€, kâ‚â‚‚, kâ‚‚â‚ (hâ»Â¹)**
        - **Vâ‚ (L)**
        """)

    elif model == "2 Compartment PO":
        safe_image("images/2CPO.png", "2-Compartment PO Model")
        st.latex(r"""
        \begin{cases}
        \frac{dA_g}{dt} = -k_a A_g \\
        \frac{dA_1}{dt} = k_a A_g - k_{10}A_1 - k_{12}A_1 + k_{21}A_2 \\
        \frac{dA_2}{dt} = k_{12}A_1 - k_{21}A_2
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_1(t)}{V_1}")
        st.markdown("""
        - **kâ‚, kâ‚â‚€, kâ‚â‚‚, kâ‚‚â‚ (hâ»Â¹)**
        - **Vâ‚ (L)**
        """)

# Î»z ì¶”ì • (ì»´íŒŒíŠ¸ë¨¼íŠ¸ ì´ˆê¸°ê°’ìš©)
def estimate_lambda_z(t, y, n_points=3):
    mask = y > 0
    t_pos = t[mask]
    c_pos = y[mask]
    if len(t_pos) < 2:
        return np.nan
    if len(t_pos) <= n_points:
        t_term, c_term = t_pos, c_pos
    else:
        t_term, c_term = t_pos[-n_points:], c_pos[-n_points:]
    if np.any(c_term <= 0):
        return np.nan
    slope, _, _, _, _ = stats.linregress(t_term, np.log(c_term))
    kel = -slope
    return kel if kel > 0 else np.nan

# ----------------------------- #
# ğŸ“ NCA Analysis
# ----------------------------- #
if analysis_type == "NCA Analysis":
    st.subheader("ğŸ“ NCA Analysis")

    auto_mode = st.radio("Terminal Phase Selection", ["Automatic", "Manual"])
    if auto_mode == "Manual":
        selected_points = st.multiselect(
            "Select terminal phase times",
            df['time'].tolist(),
            default=df['time'].tolist()[-3:]
        )
        terminal_idx = df.index[df['time'].isin(selected_points)].tolist()
    else:
        terminal_idx = None

    auc, kel, t12, cl = perform_nca(df, terminal_idx, dose)

    st.markdown(f"""
    **AUClast:** {auc:.2f} (hÂ·mg/L)
    **Î»z (kel):** {kel if np.isfinite(kel) else float('nan'):.4f} hâ»Â¹
    **t1/2:** {t12 if np.isfinite(t12) else float('nan'):.2f} h
    **CL:** {cl if np.isfinite(cl) else float('nan'):.2f} L/h
    """)

    st.subheader("ğŸ“ˆ Concentration-Time Curve")
    fig, ax = plt.subplots()
    ax.plot(df['time'], df['conc'], 'o-', label='Observed')
    ax.set_xlabel("Time (h)")
    ax.set_ylabel("Concentration (mg/L)")
    ax.legend()
    st.pyplot(fig)

# ----------------------------- #
# ğŸ§® Compartment Model Analysis
# ----------------------------- #
elif analysis_type == "Compartment Model Analysis":
    st.subheader("ğŸ§® Compartment Model Analysis")

    model = st.sidebar.selectbox(
        "Select Model",
        ["1 Compartment IV", "1 Compartment PO", "2 Compartment IV", "2 Compartment PO"]
    )
    show_model_info(model)

    use_log = st.sidebar.checkbox("Plot in Log Scale", value=False)

    # PKSolver ìŠ¤íƒ€ì¼ Weight ì„ íƒ
    weight_type = st.sidebar.selectbox(
        "Weighting (PKSolver style)",
        ["1", "1/Y", "1/Y^2"],
        index=0
    )

    # Data vectors
    t = df['time'].values.astype(float)
    y = df['conc'].values.astype(float)

    if np.any(~np.isfinite(t)) or np.any(~np.isfinite(y)):
        st.error("Non-finite values found in time/conc.")
        st.stop()

    # Weight â†’ sigma ë³€í™˜
    def make_sigma(y, weight_type):
        if weight_type == "1":
            return None
        y_pos = y.copy()
        if np.any(y_pos > 0):
            min_pos = np.min(y_pos[y_pos > 0])
        else:
            min_pos = 1.0
        y_pos[y_pos <= 0] = min_pos * 0.1
        if weight_type == "1/Y":
            sigma = np.sqrt(y_pos)      # w = 1/Y â†’ sigma â‰ˆ âˆšY
        elif weight_type == "1/Y^2":
            sigma = y_pos               # w = 1/Y^2 â†’ sigma â‰ˆ Y
        else:
            sigma = None
        return sigma

    sigma = make_sigma(y, weight_type)

    # ëª¨ë¸ í”¼íŒ… (ì „ë¶€ ODE ì‚¬ìš©)
    def fit_model(model_name, t, y, dose):
        bounds = (0, np.inf)

        kel_guess = estimate_lambda_z(t, y, n_points=3)
        if not np.isfinite(kel_guess):
            kel_guess = 0.2  # fallback

        # 1 Compartment IV
        if model_name == "1 Compartment IV":
            def model_func(tt, k10, V):
                return simulate_ode_iv(tt, dose, k10, V)

            mask = y > 0
            t_pos = t[mask]
            c_pos = y[mask]
            if len(t_pos) >= 2:
                slope, intercept, _, _, _ = stats.linregress(t_pos, np.log(c_pos))
                k0 = -slope if slope < 0 else kel_guess
                c0 = np.exp(intercept)
                V0 = dose / c0 if c0 > 0 else dose / max(y.max(), 1e-6)
            else:
                k0 = kel_guess
                V0 = dose / max(y.max(), 1e-6)

            p0 = [max(k0, 1e-4), max(V0, 1e-3)]
            param_names = ["k10", "V"]

        # 1 Compartment PO
        elif model_name == "1 Compartment PO":
            def model_func(tt, ka, k, V):
                return simulate_ode_po(tt, dose, ka, k, V)

            k0 = kel_guess
            ka0 = max(2.0 * k0, 0.5)  # ka > k ê°€ì •
            V0 = dose / max(y.max(), 1e-6)
            p0 = [ka0, max(k0, 1e-4), max(V0, 1e-3)]
            param_names = ["ka", "k", "V"]

        # 2 Compartment IV
        elif model_name == "2 Compartment IV":
            def model_func(tt, k10, k12, k21, V1):
                return simulate_ode_two_comp_iv(tt, dose, k10, k12, k21, V1)

            k10_0 = kel_guess
            k12_0 = max(k10_0 * 0.5, 0.1)
            k21_0 = max(k10_0 * 0.5, 0.1)
            V1_0 = dose / max(y.max(), 1e-6)
            p0 = [max(k10_0, 1e-4), k12_0, k21_0, max(V1_0, 1e-3)]
            param_names = ["k10", "k12", "k21", "V1"]

        # 2 Compartment PO
        elif model_name == "2 Compartment PO":
            def model_func(tt, ka, k10, k12, k21, V1):
                return simulate_ode_two_comp_po(tt, dose, ka, k10, k12, k21, V1)

            k10_0 = kel_guess
            ka0 = max(2.0 * k10_0, 0.5)
            k12_0 = max(k10_0 * 0.5, 0.1)
            k21_0 = max(k10_0 * 0.5, 0.1)
            V1_0 = dose / max(y.max(), 1e-6)
            p0 = [ka0, max(k10_0, 1e-4), k12_0, k21_0, max(V1_0, 1e-3)]
            param_names = ["ka", "k10", "k12", "k21", "V1"]

        else:
            raise ValueError("Unknown model")

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            if sigma is not None:
                popt, _ = curve_fit(
                    model_func, t, y, p0=p0, bounds=bounds,
                    sigma=sigma, absolute_sigma=False, maxfev=20000
                )
            else:
                popt, _ = curve_fit(
                    model_func, t, y, p0=p0, bounds=bounds,
                    maxfev=20000
                )

        pred = model_func(t, *popt)
        params = dict(zip(param_names, popt))
        return pred, popt, params

    try:
        pred, popt, params = fit_model(model, t, y, dose)
    except Exception as e:
        st.error(f"âŒ Fitting failed: {e}")
        st.info("Try a different model, change weighting, or check your data.")
        st.stop()

    residuals = y - pred
    ss_res = float(np.sum(residuals ** 2))
    n = len(y)
    k_params = len(popt)
    aic = n * np.log(ss_res / n) + 2 * k_params if ss_res > 0 else np.nan
    bic = n * np.log(ss_res / n) + k_params * np.log(n) if ss_res > 0 else np.nan

    col1, col2 = st.columns(2)
    with col1:
        st.subheader("ğŸ“Š Observed vs Predicted")
        fig, ax = plt.subplots()
        ax.plot(t, y, 'o', label='Observed')
        ax.plot(t, pred, '-', label='Predicted')
        ax.set_xlabel("Time (h)")
        ax.set_ylabel("Concentration (mg/L)")
        if use_log:
            ymin = max(min(y.min(), pred.min()), 1e-6)
            ax.set_ylim(bottom=ymin)
            ax.set_yscale("log")
        ax.legend()
        st.pyplot(fig)

    with col2:
        st.subheader("ğŸ§® Estimated Parameters")
        param_units = {
            "k10": "hâ»Â¹", "ka": "hâ»Â¹", "k": "hâ»Â¹",
            "k12": "hâ»Â¹", "k21": "hâ»Â¹",
            "V": "L", "V1": "L",
        }
        for kname, val in params.items():
            unit = param_units.get(kname, "")
            st.write(f"**{kname} ({unit})**: {val:.4f}")
        st.write(f"**AIC**: {aic:.2f}")
        st.write(f"**BIC**: {bic:.2f}")
        st.write(f"**Weighting:** {weight_type}")

    st.subheader("ğŸ“‰ Residual Analysis")
    fig2, ax2 = plt.subplots(1, 2, figsize=(10, 4))
    sns.histplot(residuals, kde=True, ax=ax2[0])
    ax2[0].set_title("Residual Histogram")
    ax2[1].scatter(pred, residuals)
    ax2[1].axhline(0, color='gray', linestyle='--')
    ax2[1].set_title("Residuals vs Fitted")
    ax2[1].set_xlabel("Predicted")
    ax2[1].set_ylabel("Residuals")
    st.pyplot(fig2)

    st.subheader("ğŸ“¥ Download Results")
    df_out = df.copy()
    df_out['Predicted'] = pred
    df_out['Residuals'] = residuals
    csv = df_out.to_csv(index=False)
    st.download_button("ğŸ“„ Download Results as CSV", csv, "pk_result.csv", "text/csv")