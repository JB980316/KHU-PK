# -*- coding: utf-8 -*-
"""KHU-PK-EN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v0SFgp0XrRW0ONy8clDpfwBP_BbiIYz4
"""

# -*- coding: utf-8 -*-
"""KHU-PKMA Streamlit App
NCAëŠ” ì›ë˜ ê·¸ëŒ€ë¡œ ìœ ì§€, ì»´íŒŒíŠ¸ë¨¼íŠ¸ ëª¨ë¸ì€ PKSolver ìŠ¤íƒ€ì¼ë¡œ ìˆ˜ì •
"""

# ğŸ“¦ Pharmacokinetics Integrated Analysis App
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.integrate import odeint
from scipy import stats
import warnings

# ----------------------------- #
# Streamlit page config
# ----------------------------- #
st.set_page_config(layout="wide")
st.title("ğŸ’Š KHU-PKMA")
st.caption("Pharmacokinetic Model Assistant")

# ----------------------------- #
# ğŸ“ Data Input
# ----------------------------- #
st.sidebar.header("ğŸ“‚ Data Input")
example = st.sidebar.checkbox("Use Example Data", value=True)

if example:
    time = np.array([0.5, 1, 2, 4, 6, 8, 12], dtype=float)
    conc = np.array([15.3, 13.1, 10.0, 6.1, 4.2, 2.9, 1.3], dtype=float)
    df = pd.DataFrame({'time': time, 'conc': conc})
else:
    uploaded_file = st.sidebar.file_uploader(
        "Upload CSV (must include 'time','conc' columns)", type="csv"
    )

    with st.sidebar.expander("ğŸ“ View CSV Format Example"):
        st.markdown("""
        The uploaded CSV file must follow this format:

        | time | conc |
        |------|------|
        | 0.5  | 15.3 |
        | 1.0  | 13.1 |
        | 2.0  | 10.0 |
        | ...  | ...  |

        - `time`: Time (hours, h)
        - `conc`: Drug concentration (e.g., mg/L)
        - Column names must be exactly `time`, `conc`
        - CSV must be comma-delimited
        """)

    if uploaded_file:
        df = pd.read_csv(uploaded_file)
        # Basic sanitation
        if not set(["time", "conc"]).issubset(df.columns):
            st.error("CSV must have columns named exactly 'time' and 'conc'.")
            st.stop()
        df = df.dropna(subset=["time", "conc"]).copy()
        df["time"] = pd.to_numeric(df["time"], errors="coerce")
        df["conc"] = pd.to_numeric(df["conc"], errors="coerce")
        df = df.dropna(subset=["time", "conc"]).sort_values("time")
        if len(df) < 3:
            st.error("Need at least 3 rows of (time, conc) data.")
            st.stop()
    else:
        st.warning("Please upload a CSV file or select example data.")
        st.stop()

# ----------------------------- #
# ğŸ§­ Select Analysis Type
# ----------------------------- #
analysis_type = st.sidebar.radio(
    "ğŸ” Select Analysis Type", ["NCA Analysis", "Compartment Model Analysis"]
)

# ----------------------------- #
# âš™ï¸ ê³µí†µ í•¨ìˆ˜ë“¤
# ----------------------------- #

# 1C IV analytic (PKSolver ëª¨ë¸ì‹)
def model_1c_iv(t, dose, k10, V):
    # C(t) = Dose/V * exp(-k10 * t)
    return (dose / V) * np.exp(-k10 * t)

# 1C PO analytic (ê²½êµ¬ 1êµ¬íš, first-order absorption)
def model_1c_po(t, dose, ka, k, V):
    # C(t) = (Dose * ka / (V * (ka - k))) * (exp(-k t) - exp(-ka t))
    eps = 1e-8
    ka_safe = np.maximum(ka, eps)
    k_safe = np.maximum(k, eps)
    # kaì™€ kê°€ ë„ˆë¬´ ê°€ê¹Œìš¸ ë•Œ ìˆ˜ì¹˜ ë¶ˆì•ˆì • ë°©ì§€
    if np.any(np.isclose(ka_safe, k_safe)):
        k_safe = k_safe + eps
    factor = dose * ka_safe / (V * (ka_safe - k_safe))
    return factor * (np.exp(-k_safe * t) - np.exp(-ka_safe * t))

# 2C IV (ë¯¸ë¶„ë°©ì •ì‹, í˜•íƒœë§Œ PKSolverì™€ ë™ì¼; í•´ì„í•´ ëŒ€ì‹  ODE ì‚¬ìš©)
def simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1):
    def model(y, tt):
        A1, A2 = y
        dA1dt = -k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA1dt, dA2dt]

    y0 = [dose, 0.0]
    result = odeint(model, y0, t)
    return result[:, 0] / V1

# 2C PO (ë¯¸ë¶„ë°©ì •ì‹)
def simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1):
    def model(y, tt):
        A_gut, A1, A2 = y
        dA_gut_dt = -ka * A_gut
        dA1dt = ka * A_gut - k10 * A1 - k12 * A1 + k21 * A2
        dA2dt = k12 * A1 - k21 * A2
        return [dA_gut_dt, dA1dt, dA2dt]

    y0 = [dose, 0.0, 0.0]
    result = odeint(model, y0, t)
    return result[:, 1] / V1

# === NCA (ì›ë˜ ì½”ë“œ ìœ ì§€) ===
def perform_nca(df, terminal_indices=None):
    # Filter to positive concentrations for log operations
    t = df['time'].values.astype(float)
    c = df['conc'].values.astype(float)

    # AUClast (trapezoid)
    auc = np.trapz(c, t)

    # Pick terminal points: default last 3 with positive conc
    if terminal_indices is not None and len(terminal_indices) >= 2:
        t_term = t[terminal_indices]
        c_term = c[terminal_indices]
    else:
        mask_pos = c > 0
        t_pos = t[mask_pos]
        c_pos = c[mask_pos]
        if len(t_pos) < 3:
            # Fallback: use what we have (>=2)
            t_term, c_term = t_pos[-2:], c_pos[-2:]
        else:
            t_term, c_term = t_pos[-3:], c_pos[-3:]

    if len(t_term) < 2 or np.any(c_term <= 0):
        kel = np.nan
        t12 = np.nan
    else:
        slope, _, _, _, _ = stats.linregress(t_term, np.log(c_term))
        kel = -slope
        t12 = np.log(2) / kel if kel > 0 else np.nan

    dose = st.sidebar.number_input("Dose (mg)", value=100.0)
    cl = dose / auc if auc > 0 else np.nan
    return auc, kel, t12, cl

def show_model_info(model):
    st.markdown("### ğŸ“˜ Model Description")

    if model == "1 Compartment IV":
        st.image("images/1CIV.png", caption="1-Compartment IV Model", use_container_width=True)
        st.latex(r"\frac{dA}{dt} = -k \cdot A")
        st.latex(r"C(t) = \frac{A(t)}{V} = \frac{\text{Dose}}{V} e^{-k t}")
        st.markdown("""
        - **k (Elimination rate constant, hâ»Â¹)**
        - **V (Volume of distribution, L)**
        """)

    elif model == "1 Compartment PO":
        st.image("images/1CPO.png", caption="1-Compartment PO Model", use_container_width=True)
        st.latex(r"""
        \begin{cases}
        \frac{dA_g}{dt} = -k_a A_g \\
        \frac{dA_c}{dt} = k_a A_g - k A_c
        \end{cases}
        """)
        st.latex(r"""
        C(t) = \frac{\text{Dose} \cdot k_a}{V (k_a - k)}
        \left(e^{-k t} - e^{-k_a t}\right)
        """)
        st.markdown("""
        - **kâ‚ (Absorption rate constant, hâ»Â¹)**
        - **k (Elimination rate constant, hâ»Â¹)**
        - **V (L)**
        """)

    elif model == "2 Compartment IV":
        st.image("images/2CIV.png", caption="2-Compartment IV Model", use_container_width=True)
        st.latex(r"""
        \begin{cases}
        \frac{dA_1}{dt} = -k_{10}A_1 - k_{12}A_1 + k_{21}A_2 \\
        \frac{dA_2}{dt} = k_{12}A_1 - k_{21}A_2
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_1(t)}{V_1}")
        st.markdown("""
        - **kâ‚â‚€, kâ‚â‚‚, kâ‚‚â‚ (hâ»Â¹)**
        - **Vâ‚ (L)**
        """)

    elif model == "2 Compartment PO":
        st.image("images/2CPO.png", caption="2-Compartment PO Model", use_container_width=True)
        st.latex(r"""
        \begin{cases}
        \frac{dA_g}{dt} = -k_a A_g \\
        \frac{dA_1}{dt} = k_a A_g - k_{10}A_1 - k_{12}A_1 + k_{21}A_2 \\
        \frac{dA_2}{dt} = k_{12}A_1 - k_{21}A_2
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_1(t)}{V_1}")
        st.markdown("""
        - **kâ‚, kâ‚â‚€, kâ‚â‚‚, kâ‚‚â‚ (hâ»Â¹)**
        - **Vâ‚ (L)**
        """)

# Î»z ì¶”ì • (ì»´íŒŒíŠ¸ë¨¼íŠ¸ ì´ˆê¸°ê°’ìš©)
def estimate_lambda_z(t, y, n_points=3):
    mask = y > 0
    t_pos = t[mask]
    c_pos = y[mask]
    if len(t_pos) < 2:
        return np.nan
    if len(t_pos) <= n_points:
        t_term, c_term = t_pos, c_pos
    else:
        t_term, c_term = t_pos[-n_points:], c_pos[-n_points:]
    if np.any(c_term <= 0):
        return np.nan
    slope, _, _, _, _ = stats.linregress(t_term, np.log(c_term))
    kel = -slope
    return kel if kel > 0 else np.nan

# ----------------------------- #
# ğŸ“ NCA Analysis (ì›ë˜ëŒ€ë¡œ)
# ----------------------------- #
if analysis_type == "NCA Analysis":
    st.subheader("ğŸ“ NCA Analysis")

    auto_mode = st.radio("Terminal Phase Selection", ["Automatic", "Manual"])
    if auto_mode == "Manual":
        selected_points = st.multiselect(
            "Select terminal phase times",
            df['time'].tolist(),
            default=df['time'].tolist()[-3:]
        )
        terminal_idx = df.index[df['time'].isin(selected_points)].tolist()
    else:
        terminal_idx = None

    auc, kel, t12, cl = perform_nca(df, terminal_idx)

    st.markdown(f"""
    **AUClast:** {auc:.2f} (hÂ·mg/L)
    **Î»z (kel):** {kel if np.isfinite(kel) else float('nan'):.4f} hâ»Â¹
    **t1/2:** {t12 if np.isfinite(t12) else float('nan'):.2f} h
    **CL:** {cl if np.isfinite(cl) else float('nan'):.2f} L/h
    """)

    st.subheader("ğŸ“ˆ Concentration-Time Curve")
    fig, ax = plt.subplots()
    ax.plot(df['time'], df['conc'], 'o-', label='Observed')
    ax.set_xlabel("Time (h)")
    ax.set_ylabel("Concentration (mg/L)")
    ax.legend()
    st.pyplot(fig)

# ----------------------------- #
# ğŸ§® Compartment Model Analysis (PKSolver ìŠ¤íƒ€ì¼)
# ----------------------------- #
elif analysis_type == "Compartment Model Analysis":
    st.subheader("ğŸ§® Compartment Model Analysis")

    model = st.sidebar.selectbox(
        "Select Model",
        ["1 Compartment IV", "1 Compartment PO", "2 Compartment IV", "2 Compartment PO"]
    )
    show_model_info(model)

    dose = st.sidebar.number_input("Dose (mg)", value=100.0)
    use_log = st.sidebar.checkbox("Plot in Log Scale", value=False)

    # PKSolver ìŠ¤íƒ€ì¼ Weight ì„ íƒ
    weight_type = st.sidebar.selectbox(
        "Weighting (PKSolver style)",
        ["1", "1/Y", "1/Y^2"],
        index=0
    )

    # Data vectors
    t = df['time'].values.astype(float)
    y = df['conc'].values.astype(float)

    if np.any(~np.isfinite(t)) or np.any(~np.isfinite(y)):
        st.error("Non-finite values found in time/conc.")
        st.stop()

    # ----------------------------- #
    # Weight â†’ curve_fitìš© sigma ë³€í™˜
    # PKSolver: SSE = Î£ w (y - yhat)^2
    # curve_fit: SSE = Î£ ((y - yhat)/sigma)^2  â†’  sigma = 1/âˆšw
    # w = 1      â†’ sigma = 1
    # w = 1/Y    â†’ sigma = âˆšY
    # w = 1/Y^2  â†’ sigma = Y
    # ----------------------------- #
    def make_sigma(y, weight_type):
        if weight_type == "1":
            return None
        y_pos = y.copy()
        min_pos = np.min(y_pos[y_pos > 0]) if np.any(y_pos > 0) else 1.0
        y_pos[y_pos <= 0] = min_pos * 0.1
        if weight_type == "1/Y":
            sigma = np.sqrt(y_pos)
        elif weight_type == "1/Y^2":
            sigma = y_pos
        else:
            sigma = None
        return sigma

    sigma = make_sigma(y, weight_type)

    # ----------------------------- #
    # ëª¨ë¸ í”¼íŒ… í•¨ìˆ˜
    # ----------------------------- #
    def fit_model(model_name, t, y, dose):
        """
        PKSolver ìŠ¤íƒ€ì¼ì— ê°€ê¹ê²Œ:
        - 1C IV / 1C PO: analytic solution + NLS
        - 2C IV / 2C PO: ODE + NLS (êµ¬ì¡°ëŠ” PKSolverì™€ ë™ì¼, ìˆ˜ì¹˜í•´ì„ë§Œ ì‚¬ìš©)
        """
        bounds = (0, np.inf)

        # NCA ê¸°ë°˜ kel ì¶”ì • (ì´ˆê¸°ê°’ì— ì‚¬ìš©)
        kel_guess = estimate_lambda_z(t, y, n_points=3)
        if not np.isfinite(kel_guess):
            kel_guess = 0.2  # fallback

        # 1 Compartment IV
        if model_name == "1 Compartment IV":
            def model_func(tt, k10, V):
                return model_1c_iv(tt, dose, k10, V)

            # ì´ˆê¸°ê°’: kel ê¸°ë°˜
            # ln C = ln(Dose/V) - kel t
            mask = y > 0
            t_pos = t[mask]
            c_pos = y[mask]
            if len(t_pos) >= 2:
                slope, intercept, _, _, _ = stats.linregress(t_pos, np.log(c_pos))
                k0 = -slope if slope < 0 else kel_guess
                c0 = np.exp(intercept)
                V0 = dose / c0 if c0 > 0 else dose / max(y.max(), 1e-6)
            else:
                k0 = kel_guess
                V0 = dose / max(y.max(), 1e-6)

            p0 = [max(k0, 1e-4), max(V0, 1e-3)]
            param_names = ["k10", "V"]

        # 1 Compartment PO
        elif model_name == "1 Compartment PO":
            def model_func(tt, ka, k, V):
                return model_1c_po(tt, dose, ka, k, V)

            k0 = kel_guess
            ka0 = max(2.0 * k0, 0.5)  # absorption > elimination ê°€ì •
            V0 = dose / max(y.max(), 1e-6)
            p0 = [ka0, max(k0, 1e-4), max(V0, 1e-3)]
            param_names = ["ka", "k", "V"]

        # 2 Compartment IV
        elif model_name == "2 Compartment IV":
            def model_func(tt, k10, k12, k21, V1):
                return simulate_ode_two_comp_iv(tt, dose, k10, k12, k21, V1)

            # kel ê¸°ë°˜ ëŒ€ëµì ì¸ ì´ˆê¸°ê°’
            k10_0 = kel_guess
            k12_0 = max(kel_guess * 0.5, 0.1)
            k21_0 = max(kel_guess * 0.5, 0.1)
            V1_0 = dose / max(y.max(), 1e-6)
            p0 = [max(k10_0, 1e-4), k12_0, k21_0, max(V1_0, 1e-3)]
            param_names = ["k10", "k12", "k21", "V1"]

        # 2 Compartment PO
        elif model_name == "2 Compartment PO":
            def model_func(tt, ka, k10, k12, k21, V1):
                return simulate_ode_two_comp_po(tt, dose, ka, k10, k12, k21, V1)

            k10_0 = kel_guess
            ka0 = max(2.0 * k10_0, 0.5)
            k12_0 = max(k10_0 * 0.5, 0.1)
            k21_0 = max(k10_0 * 0.5, 0.1)
            V1_0 = dose / max(y.max(), 1e-6)
            p0 = [ka0, max(k10_0, 1e-4), k12_0, k21_0, max(V1_0, 1e-3)]
            param_names = ["ka", "k10", "k12", "k21", "V1"]

        else:
            raise ValueError("Unknown model")

        # curve_fit ìˆ˜í–‰ (sigmaë¡œ Weight ë°˜ì˜)
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            if sigma is not None:
                popt, _ = curve_fit(
                    model_func, t, y, p0=p0, bounds=bounds,
                    sigma=sigma, absolute_sigma=False, maxfev=20000
                )
            else:
                popt, _ = curve_fit(
                    model_func, t, y, p0=p0, bounds=bounds,
                    maxfev=20000
                )

        pred = model_func(t, *popt)
        params = dict(zip(param_names, popt))
        return pred, popt, params

    # ----------------------------- #
    # Fit + Guard
    # ----------------------------- #
    try:
        pred, popt, params = fit_model(model, t, y, dose)
    except Exception as e:
        st.error(f"âŒ curve_fit / fitting failed: {e}")
        st.info("Tips: Try different model, adjust Dose, or provide more data points.")
        st.stop()

    residuals = y - pred
    ss_res = float(np.sum(residuals ** 2))
    n = len(y)
    k_params = len(popt)
    aic = n * np.log(ss_res / n) + 2 * k_params if ss_res > 0 else np.nan
    bic = n * np.log(ss_res / n) + k_params * np.log(n) if ss_res > 0 else np.nan

    col1, col2 = st.columns(2)
    with col1:
        st.subheader("ğŸ“Š Observed vs Predicted")
        fig, ax = plt.subplots()
        ax.plot(t, y, 'o', label='Observed')
        ax.plot(t, pred, '-', label='Predicted')
        ax.set_xlabel("Time (h)")
        ax.set_ylabel("Concentration (mg/L)")
        if use_log:
            ymin = max(min(y.min(), pred.min()), 1e-6)
            ax.set_ylim(bottom=ymin)
            ax.set_yscale("log")
        ax.legend()
        st.pyplot(fig)

    with col2:
        st.subheader("ğŸ§® Estimated Parameters")
        param_units = {
            "k10": "hâ»Â¹", "ka": "hâ»Â¹", "k": "hâ»Â¹",
            "k12": "hâ»Â¹", "k21": "hâ»Â¹",
            "V": "L", "V1": "L",
            "A": "mg/L", "B": "mg/L", "alpha": "hâ»Â¹", "beta": "hâ»Â¹"
        }
        for kname, val in params.items():
            unit = param_units.get(kname, "")
            st.write(f"**{kname} ({unit})**: {val:.4f}")
        st.write(f"**AIC**: {aic:.2f}")
        st.write(f"**BIC**: {bic:.2f}")
        st.write(f"**Weighting:** {weight_type}")

    st.subheader("ğŸ“‰ Residual Analysis")
    fig2, ax2 = plt.subplots(1, 2, figsize=(10, 4))
    sns.histplot(residuals, kde=True, ax=ax2[0])
    ax2[0].set_title("Residual Histogram")
    ax2[1].scatter(pred, residuals)
    ax2[1].axhline(0, color='gray', linestyle='--')
    ax2[1].set_title("Residuals vs Fitted")
    ax2[1].set_xlabel("Predicted")
    ax2[1].set_ylabel("Residuals")
    st.pyplot(fig2)

    st.subheader("ğŸ“¥ Download Results")
    df_out = df.copy()
    df_out['Predicted'] = pred
    df_out['Residuals'] = residuals
    csv = df_out.to_csv(index=False)
    st.download_button("ğŸ“„ Download Results as CSV", csv, "pk_result.csv", "text/csv")