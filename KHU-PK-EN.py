# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DXM4AH4tbqbdX0VN3NVemnV1RbDrsM8O
"""

# üì¶ Pharmacokinetics Integrated Analysis App
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.integrate import odeint
from scipy import stats
import warnings

# ----------------------------- #
# Streamlit page config
# ----------------------------- #
st.set_page_config(layout="wide")
st.title("üíä KHU-PKMA")
st.caption("Pharmacokinetic Model Assistant")

# ----------------------------- #
# üìÅ Data Input
# ----------------------------- #
st.sidebar.header("üìÇ Data Input")
example = st.sidebar.checkbox("Use Example Data", value=True)

if example:
    time = np.array([0.5, 1, 2, 4, 6, 8, 12], dtype=float)
    conc = np.array([15.3, 13.1, 10.0, 6.1, 4.2, 2.9, 1.3], dtype=float)
    df = pd.DataFrame({'time': time, 'conc': conc})
else:
    uploaded_file = st.sidebar.file_uploader("Upload CSV (must include 'time','conc' columns)", type="csv")

    with st.sidebar.expander("üìù View CSV Format Example"):
        st.markdown("""
        The uploaded CSV file must follow this format:

        | time | conc |
        |------|------|
        | 0.5  | 15.3 |
        | 1.0  | 13.1 |
        | 2.0  | 10.0 |
        | ...  | ...  |

        - `time`: Time (hours, h)
        - `conc`: Drug concentration (e.g., mg/L)
        - Column names must be exactly `time`, `conc`
        - CSV must be comma-delimited
        """)

    if uploaded_file:
        df = pd.read_csv(uploaded_file)
        # Basic sanitation
        if not set(["time", "conc"]).issubset(df.columns):
            st.error("CSV must have columns named exactly 'time' and 'conc'.")
            st.stop()
        df = df.dropna(subset=["time", "conc"]).copy()
        df["time"] = pd.to_numeric(df["time"], errors="coerce")
        df["conc"] = pd.to_numeric(df["conc"], errors="coerce")
        df = df.dropna(subset=["time", "conc"]).sort_values("time")
        if len(df) < 3:
            st.error("Need at least 3 rows of (time, conc) data.")
            st.stop()
    else:
        st.warning("Please upload a CSV file or select example data.")
        st.stop()

# ----------------------------- #
# üß≠ Select Analysis Type
# ----------------------------- #
analysis_type = st.sidebar.radio("üîç Select Analysis Type", ["NCA Analysis", "Compartment Model Analysis"])

# ----------------------------- #
# ‚öôÔ∏è Common Model Functions
# ----------------------------- #
def simulate_ode_iv(t, dose, k10, V):
    def ode_iv(y, tt):
        A = y[0]
        return [-k10 * A]
    y0 = [dose]
    result = odeint(ode_iv, y0, t)
    return result[:, 0] / V

def simulate_ode_po(t, dose, ka, k, V):
    def ode_po(y, tt):
        A_gut, A_c = y
        return [-ka * A_gut, ka * A_gut - k * A_c]
    y0 = [dose, 0.0]
    result = odeint(ode_po, y0, t)
    return result[:, 1] / V

def simulate_ode_two_comp_iv(t, dose, k10, k12, k21, V1):
    def model(y, tt):
        A1, A2 = y
        dA1dt = -k10*A1 - k12*A1 + k21*A2
        dA2dt = k12*A1 - k21*A2
        return [dA1dt, dA2dt]
    y0 = [dose, 0.0]
    result = odeint(model, y0, t)
    return result[:, 0] / V1

def simulate_ode_two_comp_po(t, dose, ka, k10, k12, k21, V1):
    def model(y, tt):
        A_gut, A1, A2 = y
        dA_gut_dt = -ka * A_gut
        dA1dt = ka*A_gut - k10*A1 - k12*A1 + k21*A2
        dA2dt = k12*A1 - k21*A2
        return [dA_gut_dt, dA1dt, dA2dt]
    y0 = [dose, 0.0, 0.0]
    result = odeint(model, y0, t)
    return result[:, 1] / V1

def perform_nca(df, terminal_indices=None):
    # Filter to positive concentrations for log operations
    t = df['time'].values.astype(float)
    c = df['conc'].values.astype(float)

    # AUClast (trapezoid)
    auc = np.trapz(c, t)

    # Pick terminal points: default last 3 with positive conc
    if terminal_indices is not None and len(terminal_indices) >= 2:
        t_term = t[terminal_indices]
        c_term = c[terminal_indices]
    else:
        mask_pos = c > 0
        t_pos = t[mask_pos]
        c_pos = c[mask_pos]
        if len(t_pos) < 3:
            # Fallback: use what we have (>=2)
            t_term, c_term = t_pos[-2:], c_pos[-2:]
        else:
            t_term, c_term = t_pos[-3:], c_pos[-3:]

    if len(t_term) < 2 or np.any(c_term <= 0):
        kel = np.nan
        t12 = np.nan
    else:
        slope, _, _, _, _ = stats.linregress(t_term, np.log(c_term))
        kel = -slope
        t12 = np.log(2) / kel if kel > 0 else np.nan

    dose = st.sidebar.number_input("Dose (mg)", value=100.0)
    cl = dose / auc if auc > 0 else np.nan
    return auc, kel, t12, cl

def show_model_info(model):
    st.markdown("### üìò Model Description")

    if model == "1 Compartment IV":
        st.image("images/1CIV.png", caption="1-Compartment IV Model", use_container_width=True)
        st.latex(r"\frac{dA}{dt} = -k \cdot A")
        st.latex(r"C(t) = \frac{A(t)}{V}")
        st.markdown("""
        - **k (Elimination rate constant, h‚Åª¬π)**: Elimination from the central compartment
        - **V (Volume of distribution, L)**
        """)

    elif model == "1 Compartment PO":
        st.image("images/1CPO.png", caption="1-Compartment PO Model", use_container_width=True)
        st.latex(r"""
        \begin{cases}
        \frac{dA_g}{dt} = -k_a A_g \\
        \frac{dA_c}{dt} = k_a A_g - k A_c
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_c(t)}{V}")
        st.markdown("""
        - **k‚Çê (Absorption rate constant, h‚Åª¬π)**
        - **k (Elimination rate constant, h‚Åª¬π)**
        - **V (L)**
        """)

    elif model == "2 Compartment IV":
        st.image("images/2CIV.png", caption="2-Compartment IV Model", use_container_width=True)
        st.latex(r"""
        \begin{cases}
        \frac{dA_1}{dt} = -k_{10}A_1 - k_{12}A_1 + k_{21}A_2 \\
        \frac{dA_2}{dt} = k_{12}A_1 - k_{21}A_2
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_1(t)}{V_1}")
        st.markdown("""
        - **k‚ÇÅ‚ÇÄ, k‚ÇÅ‚ÇÇ, k‚ÇÇ‚ÇÅ (h‚Åª¬π)**
        - **V‚ÇÅ (L)**
        """)

    elif model == "2 Compartment PO":
        st.image("images/2CPO.png", caption="2-Compartment PO Model", use_container_width=True)
        st.latex(r"""
        \begin{cases}
        \frac{dA_g}{dt} = -k_a A_g \\
        \frac{dA_1}{dt} = k_a A_g - k_{10}A_1 - k_{12}A_1 + k_{21}A_2 \\
        \frac{dA_2}{dt} = k_{12}A_1 - k_{21}A_2
        \end{cases}
        """)
        st.latex(r"C(t) = \frac{A_1(t)}{V_1}")
        st.markdown("""
        - **k‚Çê, k‚ÇÅ‚ÇÄ, k‚ÇÅ‚ÇÇ, k‚ÇÇ‚ÇÅ (h‚Åª¬π)**
        - **V‚ÇÅ (L)**
        """)

# ----------------------------- #
# üìê NCA Analysis
# ----------------------------- #
if analysis_type == "NCA Analysis":
    st.subheader("üìê NCA Analysis")

    auto_mode = st.radio("Terminal Phase Selection", ["Automatic", "Manual"])
    if auto_mode == "Manual":
        selected_points = st.multiselect(
            "Select terminal phase times",
            df['time'].tolist(),
            default=df['time'].tolist()[-3:]
        )
        terminal_idx = df.index[df['time'].isin(selected_points)].tolist()
    else:
        terminal_idx = None

    auc, kel, t12, cl = perform_nca(df, terminal_idx)

    st.markdown(f"""
    **AUClast:** {auc:.2f} (h¬∑mg/L)
    **Œªz (kel):** {kel if np.isfinite(kel) else float('nan'):.4f} h‚Åª¬π
    **t1/2:** {t12 if np.isfinite(t12) else float('nan'):.2f} h
    **CL:** {cl if np.isfinite(cl) else float('nan'):.2f} L/h
    """)

    st.subheader("üìà Concentration-Time Curve")
    fig, ax = plt.subplots()
    ax.plot(df['time'], df['conc'], 'o-', label='Observed')
    ax.set_xlabel("Time (h)")
    ax.set_ylabel("Concentration (mg/L)")
    ax.legend()
    st.pyplot(fig)

# ----------------------------- #
# üßÆ Compartment Model Analysis
# ----------------------------- #
elif analysis_type == "Compartment Model Analysis":
    st.subheader("üßÆ Compartment Model Analysis")

    model = st.sidebar.selectbox(
        "Select Model",
        ["1 Compartment IV", "1 Compartment PO", "2 Compartment IV", "2 Compartment PO"]
    )

    show_model_info(model)

    dose = st.sidebar.number_input("Dose (mg)", value=100.0)
    use_log = st.sidebar.checkbox("Plot in Log Scale", value=False)

    # Data vectors
    t = df['time'].values.astype(float)
    y = df['conc'].values.astype(float)

    # Guard against negatives/NaNs
    if np.any(~np.isfinite(t)) or np.any(~np.isfinite(y)):
        st.error("Non-finite values found in time/conc.")
        st.stop()

    # ----------------------------- #
    # Robust curve fitting wrapper
    # ----------------------------- #
    def fit_model(model_name, t, y, dose):
        """
        Returns: pred, popt, params_dict
        Raises on failure.
        """
        # Sensible default bounds: all params positive
        bounds = (0, np.inf)

        # Choose model function and initial guesses
        if model_name == "1 Compartment IV":
            def model_func(tt, k10, V):
                return simulate_ode_iv(tt, dose, k10, V)
            p0 = [0.2, max(1.0, dose / max(y.max(), 1e-6))]  # k10 ~0.2 h^-1, V ~ dose/Cmax

            param_names = ["k10", "V"]

        elif model_name == "1 Compartment PO":
            def model_func(tt, ka, k, V):
                return simulate_ode_po(tt, dose, ka, k, V)
            # ka usually > k, start with ka=1.0, k=0.2, V similar heuristic
            p0 = [1.0, 0.2, max(1.0, dose / max(y.max(), 1e-6))]
            param_names = ["ka", "k", "V"]

        elif model_name == "2 Compartment IV":
            def model_func(tt, k10, k12, k21, V1):
                return simulate_ode_two_comp_iv(tt, dose, k10, k12, k21, V1)
            p0 = [0.2, 0.1, 0.1, max(1.0, dose / max(y.max(), 1e-6))]
            param_names = ["k10", "k12", "k21", "V1"]

        elif model_name == "2 Compartment PO":
            def model_func(tt, ka, k10, k12, k21, V1):
                return simulate_ode_two_comp_po(tt, dose, ka, k10, k12, k21, V1)
            p0 = [1.2, 0.2, 0.1, 0.1, max(1.0, dose / max(y.max(), 1e-6))]
            param_names = ["ka", "k10", "k12", "k21", "V1"]

        else:
            raise ValueError("Unknown model")

        # Suppress harmless warnings from curve_fit but catch real failures
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            popt, _ = curve_fit(model_func, t, y, p0=p0, bounds=bounds, maxfev=20000)

        pred = model_func(t, *popt)
        params = dict(zip(param_names, popt))
        return pred, popt, params

    # ----------------------------- #
    # Fit + Guard: ensure pred is defined or stop
    # ----------------------------- #
    try:
        pred, popt, params = fit_model(model, t, y, dose)
    except Exception as e:
        st.error(f"‚ùå curve_fit failed: {e}")
        st.info("Tips: Try different model, adjust Dose, or provide more data points.")
        st.stop()

    # Results
    residuals = y - pred
    ss_res = float(np.sum(residuals ** 2))
    n = len(y)
    k_params = len(popt)
    aic = n * np.log(ss_res / n) + 2 * k_params if ss_res > 0 else np.nan
    bic = n * np.log(ss_res / n) + k_params * np.log(n) if ss_res > 0 else np.nan

    col1, col2 = st.columns(2)
    with col1:
        st.subheader("üìä Observed vs Predicted")
        fig, ax = plt.subplots()
        ax.plot(t, y, 'o', label='Observed')
        ax.plot(t, pred, '-', label='Predicted')
        ax.set_xlabel("Time (h)")
        ax.set_ylabel("Concentration (mg/L)")
        if use_log:
            # avoid log of non-positive
            ymin = max(min(y.min(), pred.min()), 1e-6)
            ax.set_ylim(bottom=ymin)
            ax.set_yscale("log")
        ax.legend()
        st.pyplot(fig)

    with col2:
        st.subheader("üßÆ Estimated Parameters")
        param_units = {
            "k10": "h‚Åª¬π", "ka": "h‚Åª¬π", "k": "h‚Åª¬π",
            "k12": "h‚Åª¬π", "k21": "h‚Åª¬π",
            "V": "L", "V1": "L",
            "A": "mg/L", "B": "mg/L", "alpha": "h‚Åª¬π", "beta": "h‚Åª¬π"
        }
        for kname, val in params.items():
            unit = param_units.get(kname, "")
            st.write(f"**{kname} ({unit})**: {val:.4f}")
        st.write(f"**AIC**: {aic:.2f}")
        st.write(f"**BIC**: {bic:.2f}")

    st.subheader("üìâ Residual Analysis")
    fig2, ax2 = plt.subplots(1, 2, figsize=(10, 4))
    sns.histplot(residuals, kde=True, ax=ax2[0])
    ax2[0].set_title("Residual Histogram")
    ax2[1].scatter(pred, residuals)
    ax2[1].axhline(0, color='gray', linestyle='--')
    ax2[1].set_title("Residuals vs Fitted")
    ax2[1].set_xlabel("Predicted")
    ax2[1].set_ylabel("Residuals")
    st.pyplot(fig2)

    st.subheader("üì• Download Results")
    df_out = df.copy()
    df_out['Predicted'] = pred
    df_out['Residuals'] = residuals
    csv = df_out.to_csv(index=False)
    st.download_button("üìÑ Download Results as CSV", csv, "pk_result.csv", "text/csv")
